<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>许正扬 开发日志</title>
  <style>
    :root { --fg: #222; --muted: #666; --border: #cfcfcf; --bg-muted: #f6f6f6; }
    body { font-family: "Microsoft YaHei", "Noto Sans CJK SC", sans-serif; line-height: 1.9; margin: 32px; color: var(--fg); }
    h1, h2, h3, h4 { margin: 0 0 12px; }
    h1 { font-size: 26px; }
    h2 { font-size: 18px; margin-top: 26px; padding-top: 6px; border-top: 1px solid #eee; }
    h3 { font-size: 15px; margin-top: 18px; }
    h4 { font-size: 14px; margin-top: 14px; }
    p { margin: 10px 0; }
    ul, ol { margin: 8px 0 8px 22px; }
    li { margin: 4px 0; }
    pre { background: var(--bg-muted); padding: 12px; border-radius: 8px; overflow-x: auto; }
    code { background: var(--bg-muted); padding: 1px 4px; border-radius: 4px; }
    table { border-collapse: collapse; width: 100%; margin: 10px 0; }
    th, td { border: 1px solid var(--border); padding: 8px 10px; vertical-align: top; }
    th { background: #fafafa; }
    .muted { color: var(--muted); }
    .note { background: #fff7e6; padding: 10px 12px; border-left: 4px solid #f0b429; margin: 10px 0; }
    .callout { border-left: 4px solid #3b82f6; background: #eff6ff; padding: 10px 12px; margin: 10px 0; }
  </style>
</head>
<body>
  <h1>个人开发日志（许正扬）</h1>
  <p class="muted">项目：轻写（QingXie）AI 辅助小说创作平台（前后端分离）</p>
  <p>身份：组长　　主要负责：后端、数据库、鉴权、AI 接口、联调与交付检查</p>

  <h2>0. 开发环境准备（记录型说明）</h2>
  <p>
    本项目后端采用 Python FastAPI，前端采用 React/Next.js。为了保证本地开发可重复，我先统一了开发环境与基本工具链，
    并将关键运行步骤整理成可复制命令，保证组员拉取代码后能够在同一套流程下启动服务与自测。
  </p>
  <table>
    <thead><tr><th>组件</th><th>版本/说明</th><th>备注</th></tr></thead>
    <tbody>
      <tr><td>Python</td><td>3.10+</td><td>后端运行环境</td></tr>
      <tr><td>Node.js</td><td>18+</td><td>前端运行环境</td></tr>
      <tr><td>数据库</td><td>SQLite（默认）/ MySQL 8.0（可选）</td><td>SQLite 用于快速验收；MySQL 用于生产模式</td></tr>
      <tr><td>接口测试工具</td><td>Postman / Apifox</td><td>用于验证登录、CRUD、AI 等接口</td></tr>
    </tbody>
  </table>
  <div class="note">截图建议：图1（环境安装完成截图：Python/Node 版本号输出）。</div>

  <h2>2025-12-18 开发记录（后端主线实现 + 联调）</h2>
  <h3>1. 需求拆分与数据模型草拟</h3>
  <p>
    当天首先把核心业务主线固定下来：用户登录后以“作品”为中心进行创作管理；每个作品下面有多个章节；此外提供角色/大纲/世界观作为设定支撑；
    在写作过程中提供 AI 辅助能力（续写、润色等），并把生成结果回填到章节内容中。
    结合这些业务，我确定了数据库实体关系：users（1）-（N）novels，novels（1）-（N）chapters，novels（1）-（N）characters/outlines，
    以及 novels（1）-（1）world_buildings。
  </p>
  <div class="note">截图建议：图2（数据库表/ER 草图，手画也可，拍照插入）。</div>

  <h3>2. 后端工程初始化与基础能力搭建</h3>
  <p>
    我按 FastAPI 的目录组织方式创建后端工程：将路由（api）、模型（models）、数据校验（schemas）、业务逻辑（services）分层，
    这样做的目的是让 controller 只负责“接收参数与返回响应”，把复杂逻辑放在 service 中，便于后续维护与测试。
  </p>
  <p>
    同时完成基础配置：通过环境变量管理数据库连接串与密钥；添加 CORS 允许前端跨域调用；增加健康检查接口 <code>/health</code>；
    在应用启动时自动创建表（开发阶段快速验证）。
  </p>
  <div class="callout">
    验证方法：启动后端后访问 <code>GET /health</code>，返回 <code>{"status":"ok"}</code> 视为后端基础运行正常。
  </div>
  <div class="note">截图建议：图3（后端启动终端 + /health 返回）。</div>

  <h3>3. 认证模块：注册、登录、JWT 鉴权</h3>
  <p>
    为了满足“有用户体系”的验收要求，后端实现了注册与登录。注册接口用于创建用户（email、name、password 等），密码不以明文存储，
    而是先加密后落库。登录接口使用表单方式接收账号密码，验证通过后签发 JWT Token。
  </p>
  <p>
    鉴权采用 Bearer Token：前端登录成功后保存 token，后续请求在 Header 中携带 <code>Authorization: Bearer &lt;token&gt;</code>。
    在后端实现依赖项解析 token 并得到当前用户对象，从而实现所有业务接口的数据隔离（任何查询都要带上 user_id 过滤）。
  </p>
  <h4>接口自测记录（示例）</h4>
  <pre><code>1) 注册
POST /auth/register
Body(JSON): {"email":"test@qq.com","name":"test","password":"123456"}

2) 登录
POST /auth/login
Body(Form): username=test@qq.com, password=123456

3) 获取当前用户
GET /auth/me
Header: Authorization: Bearer &lt;token&gt;</code></pre>
  <div class="note">截图建议：图4（Postman/Apifox 的注册与登录测试截图）。</div>

  <h3>4. 作品与章节：CRUD 与统计一致性</h3>
  <p>
    后端围绕作品与章节提供 CRUD 接口。作品包含标题、简介、分类、标签、状态等字段；章节包含标题、正文、顺序号与字数等。
    其中“字数/章节数统计”是写作系统典型的细节要求：如果只让前端计算，容易出现口径不一致或漏更新问题，因此我把统计逻辑放到后端统一维护。
  </p>
  <p>
    具体实现方式是：每次新增、更新、删除章节后，后端会对该作品下的章节表做聚合查询（sum(word_count)、count(id)），
    更新 novels 表中的统计字段。这样前端只需要展示后端返回的统计结果即可，避免重复实现。
  </p>
  <h4>（补充）典型接口与返回字段样例</h4>
  <p>
    为了让前端更容易直接渲染页面，我尽量在资源返回中包含“页面必需字段”。以下是典型接口的返回字段示例（以实际接口返回为准）。
  </p>
  <pre><code>创建作品：POST /novels
Body(JSON): {"title":"示例作品","description":"...","genre":"奇幻","tags":["热血","成长"]}

返回（示例）：
{
  "id": "uuid",
  "title": "示例作品",
  "description": "...",
  "genre": "奇幻",
  "status": "draft",
  "tags": "[\"热血\",\"成长\"]",
  "word_count": 0,
  "chapter_count": 0,
  "created_at": "...",
  "updated_at": "..."
}</code></pre>
  <pre><code>创建章节：POST /novels/{id}/chapters
Body(JSON): {"title":"第1章","content":"正文..."}

返回（示例）：
{
  "id": "uuid",
  "title": "第1章",
  "content": "正文...",
  "order": 1,
  "word_count": 123,
  "status": "draft",
  "novel_id": "uuid"
}</code></pre>
  <p>
    在章节创建/更新后，再调用 <code>GET /novels/{id}</code> 可看到作品的 <code>word_count</code> 与 <code>chapter_count</code> 已更新，
    这部分逻辑由后端统一维护，前端无需手动汇总。
  </p>
  <div class="note">截图建议：图5（创建作品、创建章节、更新章节后统计字段变化的接口测试截图）。</div>

  <h3>5. 角色/大纲/世界观模块</h3>
  <p>
    在写作类系统中，设定信息往往比正文更容易混乱。因此我把角色、大纲、世界观设计成作品维度的独立模块，并提供相应的增删改查接口。
    世界观采用“单条记录可更新”的方式（upsert 语义），避免一个作品里出现多条世界观设定互相冲突。
  </p>
  <div class="note">截图建议：图6（角色/大纲/世界观接口测试截图）。</div>

  <h3>6. AI 能力：接口封装与错误兜底</h3>
  <p>
    AI 能力由后端统一封装，核心原因是：提示词模板、模型参数、返回解析与错误处理属于服务端能力，放在后端便于统一控制和维护。
    我在后端实现 AI 续写接口：前端提交上下文与需求，后端拼装请求调用外部大模型服务，得到结果后返回给前端。
  </p>
  <p>
    AI 调用存在不确定性（Key 未配置、网络超时、返回结构变化），因此我增加了兜底逻辑：
    未配置 Key 时返回明确错误提示；调用超时给出可读错误；解析时校验 choices/content 字段是否存在，缺失时输出可定位信息，方便排查。
  </p>
  <div class="note">截图建议：图7（配置 DOUBAO_API_KEY 后的 AI 续写接口调用截图；若未配置可截图“提示未配置 Key”的返回）。</div>

  <h3>7. 与前端联调（协作记录）</h3>
  <p>
    与组员联调时，重点验证三件事：第一，登录会话是否稳定（token 能否正确携带）；第二，作品与章节数据是否按用户隔离；
    第三，新增/修改后前端列表是否能及时刷新并正确展示统计数据。在联调过程中，我根据前端需要补齐了一些返回字段与错误提示，
    并确认了前端调用路径与参数格式（JSON 或表单）。
  </p>

  <h3>8. 数据库配置与验证（SQLite / MySQL）</h3>
  <p>
    为了保证验收现场“随时可跑”，后端默认使用 SQLite：无需安装数据库服务，启动后自动生成 <code>backend/app.db</code> 并创建表结构。
    在完成主流程验证后，再切换到 MySQL 模式，以满足生产部署场景。两种模式在 ORM 层保持一致，因此切换成本主要在配置与连接验证。
  </p>
  <p>（1）SQLite 快速验证步骤</p>
  <pre><code>uvicorn app.main:app --reload --app-dir backend
GET http://localhost:8000/health
POST /auth/register → POST /auth/login → GET /auth/me</code></pre>
  <p>（2）MySQL 模式验证步骤（示例）</p>
  <pre><code># 创建库（在 MySQL 控制台执行）
CREATE DATABASE aiwrite_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# backend/.env 中配置
DATABASE_URL=mysql+pymysql://aiwrite_user:123456@localhost:3306/aiwrite_db?charset=utf8mb4</code></pre>
  <p>
    切换后重启后端，重复“注册/登录/创建作品/创建章节”流程，确认数据写入 MySQL 并可持久化。
  </p>
  <div class="note">截图建议：图8（MySQL 创建库截图或控制台截图 + 后端切换配置截图）。</div>

  <h3>9. 关键文件与模块定位（便于老师查阅代码）</h3>
  <p>
    为了让代码结构更清晰，我把后端按“路由—模型—业务—工具”分层。下面列出核心文件入口，老师或助教如果需要快速定位实现，可按此路径查看。
  </p>
  <table>
    <thead><tr><th>功能</th><th>文件/目录</th><th>说明</th></tr></thead>
    <tbody>
      <tr><td>应用入口</td><td><code>backend/app/main.py</code></td><td>创建 FastAPI app、CORS、路由注册、/health</td></tr>
      <tr><td>配置读取</td><td><code>backend/app/config.py</code></td><td>读取 backend/.env，提供数据库与密钥配置</td></tr>
      <tr><td>数据库连接</td><td><code>backend/app/database.py</code></td><td>SQLAlchemy engine/session/base</td></tr>
      <tr><td>模型定义</td><td><code>backend/app/models/</code></td><td>users/novels/chapters/characters/outlines/world_building</td></tr>
      <tr><td>认证路由</td><td><code>backend/app/api/auth.py</code></td><td>注册、登录、获取当前用户</td></tr>
      <tr><td>作品/章节路由</td><td><code>backend/app/api/novels.py</code> 等</td><td>CRUD、按用户隔离</td></tr>
      <tr><td>业务逻辑</td><td><code>backend/app/services/</code></td><td>auth_service、novel_service、chapter_service、ai_service</td></tr>
      <tr><td>安全工具</td><td><code>backend/app/utils/security.py</code></td><td>密码 hash、JWT token、UUID 生成</td></tr>
    </tbody>
  </table>

  <h3>10. 依赖与兼容性问题记录（排错型流水账）</h3>
  <p>
    在搭建登录接口时，需要使用 OAuth2 表单方式提交账号密码。FastAPI 解析表单依赖 <code>python-multipart</code>，
    否则启动或请求会报错。为避免环境差异导致同学运行失败，我将该依赖明确写入 <code>backend/requirements.txt</code> 并在本地验证无误。
  </p>
  <p>
    同时，注册接口对 email 格式校验依赖 <code>email-validator</code>。若缺失该库，Pydantic 在验证 EmailStr 时会提示缺少依赖。
    因此同样把该库纳入依赖列表，确保“注册—登录—鉴权”主流程可稳定运行。
  </p>
  <div class="note">截图建议：图9（requirements.txt 关键依赖截图 + 运行成功截图）。</div>

  <h2>2025-12-20 交付记录（文档整理 + 最终自测）</h2>
  <h3>1. 文档整理</h3>
  <p>
    按照课程要求，本阶段主要完成：系统说明文档、系统使用与部署说明文档、组内工作量说明、个人开发日志等材料的整理。
    文档采用 HTML 输出，便于后续复制到 Word 或直接转 PDF 提交。
  </p>
  <h3>2. 最终自测与验收脚本化</h3>
  <p>
    为保证答辩现场稳定，我按“最短可演示路径”进行自测，并将关键步骤整理为可复制命令与验收流程：
    启动后端 → 启动前端 → 注册 → 登录 → 创建作品 → 创建章节 → 保存正文 → 添加角色/大纲/世界观 →（可选）AI 续写 → 导出。
    其中 AI 功能作为加分项，未配置 Key 时不影响主功能演示。
  </p>
  <div class="callout">
    建议在答辩时准备：一个测试账号、一个示例作品、一个示例章节内容（100–200 字），演示更连贯。
  </div>

  <h2>版本管理记录（简要）</h2>
  <p>
    项目使用 GitHub 进行版本管理，按功能阶段进行提交。提交信息主要包括工程初始化、后端与数据库实现等。
    （若老师要求展示 commit 截图，可在 GitHub 的 commits 页面截图插入。）</p>
  <div class="note">截图建议：图10（GitHub 提交记录截图）。</div>

  <p class="muted">备注：本日志为“可提交版本”。如需更贴合个人实际开发过程，可在不改变事实的前提下补充具体截图、命令输出与接口测试记录。</p>
</body>
</html>
